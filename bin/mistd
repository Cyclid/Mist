#!/usr/bin/env ruby
$LOAD_PATH.push File.expand_path('../../lib', __FILE__)

require 'logger'
require 'optparse'
require 'msgpack/rpc'
require 'mist/logger'
require 'mist/config'

begin
  require 'mist/handlers/gce'
rescue LoadError
  STDERR.puts 'GCE is not available'
end

begin
  require 'mist/handlers/lxc'
rescue LoadError
  STDERR.puts 'LXC is not available'
end

options = { daemonize: false, config: File.join(%w(/ etc mist config)), type: nil, workers: 5 }
OptionParser.new do |opts|
  opts.on('-d', '--daemon', 'Run the Mist server as a background daemon') do |_daemon|
    options[:daemonize] = true
  end

  opts.on('-c', '--config PATH', 'Path to the configuration file') do |path|
    options[:config] = path
  end

  opts.on('-t', '--type TYPE', 'Type of instances to create ("gce" or "lxc")') do |type|
    options[:type] = type
  end

  opts.on('-w', '--workers NUM', 'Number of workers to create') do |num|
    options[:workers] = num
  end
end.parse!

abort 'You must specify the server type: one of "lxc" or "gce"' unless options[:type]

config = Mist::Config.new(options[:config])
Mist.logger.debug config.inspect

if options[:daemonize]
  # Provide our own file logger
  Mist.logger = Logger.new(File.join(%w(/ var log mist.log)))

  # Become a daemon & start processing requests
  Process.daemon(false, false)
else
  # Log to stderr
  Mist.logger = Logger.new(STDERR)
end

# Start the RPC event loop
begin
  Mist.logger.info "Mist server starting with PID #{Process.pid}"

  if options[:type] == 'gce'
    for num in 0..options[:workers]
      server = Mist::GceServer.new(config, num)
      server.run
    end
  elsif options[:type] == 'lxc'
    for num in 0..options[:workers]
      server = Mist::LxcServer.new(config, num)
      server.run
    end
  else
    abort "Unknown server type #{options[:type]}"
  end
rescue StandardError => ex
  Mist.logger.error "failed to start Mist server: #{ex}"
  abort
end

Mist.logger.info 'Mist server exiting'
exit 0
