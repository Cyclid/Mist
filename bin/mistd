#!/usr/bin/env ruby2.0
$LOAD_PATH.push File.expand_path('../../lib', __FILE__)

require 'logger'
require 'securerandom'
require 'optparse'
require 'mist/logger'
require 'msgpack/rpc'
require 'fog/google'
require 'socket'

class MistHandler
  def initialize
    @api = Fog::Compute.new(provider: 'Google')
  end

  def create(args)
    Mist.logger.debug "create: args=#{args}"

    #hostname = Socket.gethostname
    hostname = '104.155.84.154'

    distro = args['distro'] || 'ubuntu'
    release = args['release'] || 'trusty'
    name = args['name'] || create_name

    username = 'build'
    ssh_pub_key = File.expand_path('~/.ssh/id_rsa_build.pub')
    network = 'builders'
    zone = 'europe-west1-b'
    machine_type = 'f1-micro'

    begin
      # Map the distro & release to a source image
      Mist.logger.debug 'attempting to find source image'

      source_image = nil
      disk_size = 0

      @api.images.all.each do |image|
        next if image.deprecated

        match = image.name.match(/^#{distro}-((\d*)-(.*)-v.*$|(\d*)-v.*$)/)
        next unless match
        next unless match[2] == release or match[3] == release

        # Found one
        Mist.logger.info "found image #{image.name} for #{distro}:#{release}"
        source_image = image.name
        disk_size = image.disk_size_gb

        break
      end

      # If we didn't find a disk, we have to stop now
      raise "could not find suitable source image for #{distro}:#{release}" \
        unless source_image

      # Create a disk, create an instance with the disk attached, set the disk
      # to be auto-deleted when the instance is destroyed
      Mist.logger.info "creating disk #{name}"
      disk = @api.disks.create(name: name,
                              size_gb: disk_size,
                              zone_name: zone,
                              source_image: source_image)

      Mist.logger.info 'waiting for disk...'
      disk.wait_for { disk.ready? }

      Mist.logger.info "creating instance #{name}"

      metadata = {'startup-script' => File.read('/etc/mist/startup-script'),
                  'mist-user' => 'build',
                  'mist-key' => File.read(ssh_pub_key)}

      instance = @api.servers.create(name: name,
                                     disks: [disk],
                                     machine_type: machine_type,
                                     zone_name: zone,
                                     network: network,
                                     metadata: metadata,
                                     tags: ['build','build-host'])

      device_name = instance.disks[0]['deviceName']
      instance.set_disk_auto_delete(true, device_name)

      instance.wait_for { instance.ready? }

      ip = instance.public_ip_address #private_ip_address
    rescue StandardError => ex
      Mist.logger.error "Create request failed: #{ex}"
      return { status: false, server: hostname, message: "create request failed: #{ex}" }
    end

    return { status: true,
             server: hostname,
             message: 'created new instance',
             name: name, ip: ip,
             username: username }
  end

  def destroy(args)
    Mist.logger.debug "destroy: args=#{args}"

    begin
      name = args['name']

      instance = @api.servers.get(name)
      raise "instance #{name} does not exist" unless instance

      Mist.logger.info "destroying #{name}"
      raise 'failed to destroy instance' unless instance.destroy
    rescue StandardError => ex
      Mist.logger.error "Destroy request failed: #{ex}"
      return { status: false, message: "destroy request failed: #{ex}" }
    end

    return { status: true, message: 'destroyed instance', name: name }
  end

  private

  def create_name
    # XXX Make the base a configuration option
    base = 'buildhost'
    "#{base}-#{SecureRandom.hex(16)}"
  end
end

class MistServer
  def initialize
    @server = MessagePack::RPC::Server.new
    @server.listen('0.0.0.0', 18800, MistHandler.new)
  end

  def run
    @server.run
  end
end

options = { daemonize: false, config: File.join(%w(/ etc mist server)) }
OptionParser.new do |opts|
  opts.on('-d', '--daemon', 'Run the Mist server as a background daemon') do |_daemon|
    options[:daemonize] = true
  end

  opts.on('-c', '--config PATH', 'Path to the configuration file') do |config|
    options[:config] = config
  end
end

if options[:daemonize]
  # Provide our own file logger
  Mist.logger = Logger.new(File.join(%w(/ var log mist.log)))

  # Become a daemon & start processing requests
  Process.daemon(false, false)
else
  # Log to stderr
  Mist.logger = Logger.new(STDERR)
end

# Start the RPC event loop
begin
  Mist.logger.info "Mist server starting with PID #{Process.pid}"

  server = MistServer.new
  server.run
rescue StandardError => ex
  Mist.logger.error "failed to start Mist server: #{ex}"
  abort
end

Mist.logger.info 'Mist server exiting'
exit 0
