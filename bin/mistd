#!/usr/bin/env ruby2.0
$LOAD_PATH.push File.expand_path('../../lib', __FILE__)

require 'logger'
require 'mist/logger'
require 'msgpack/rpc'
require 'fog/google'
require 'socket'

class MistHandler
  def initialize
    @api = Fog::Compute.new(provider: 'Google')
  end

  def create(args)
    Mist.logger.debug "create: args=#{args}"

    #hostname = Socket.gethostname
    hostname = '104.155.84.154'

    distro = args['distro'] || 'ubuntu'
    release = args['release'] || 'trusty'
    name = args['name'] || create_name
    username = 'ubuntu'
    network = 'builders'
    zone = 'europe-west1-b'

    # XXX Map the distro & release to a source image

    begin
      Mist.logger.debug 'creating disk'
      disk = @api.disks.create(name: name,
                              size_gb: 10,
                              zone_name: zone,
                              source_image: 'ubuntu-1404-trusty-v20160222')

      Mist.logger.debug 'waiting for disk...'
      disk.wait_for { disk.ready? }

      Mist.logger.debug 'creating instance'
      instance = @api.servers.create(name: name,
                                     disks: [disk],
                                     machine_type: 'f1-micro',
                                     private_key_path: File.expand_path('~/.ssh/id_rsa_build'),
                                     public_key_path: File.expand_path('~/.ssh/id_rsa_build.pub'),
                                     zone_name: zone,
                                     network: network,
                                     username: username,
                                     tags: ['build','build-host'])

      device_name = instance.disks[0]['deviceName']
      instance.set_disk_auto_delete(true, device_name)

      instance.wait_for { instance.sshable? }

      ip = instance.public_ip_address #private_ip_address
    rescue StandardError => ex
      Mist.logger.error "Create request failed: #{ex}"
      return { status: false, server: hostname, message: "create request failed: #{ex}" }
    end

    return { status: true, server: hostname, message: 'created new instance', name: name, ip: ip, username: username }
  end

  def destroy(args)
    Mist.logger.debug "destroy: args=#{args}"

    begin
      name = args['name']

      instance = @api.servers.get(name)
      raise "instance #{name} does not exist" unless instance

      Mist.logger.info "destroying #{name}"
      raise 'failed to destroy instance' unless instance.destroy
    rescue StandardError => ex
      Mist.logger.error "Destroy request failed: #{ex}"
      return { status: false, message: "destroy request failed: #{ex}" }
    end

    return { status: true, message: 'destroyed instance', name: name }
  end

  private

  def create_name
    # Create a suitable name
    filename = File.join(ENV['HOME'], '.mist', 'lxc-sequence')

    # Create an empty sequence file if one doesn't exist
    File.new(filename, 'w') unless File.exist?(filename)

    # Read the last sequence, increment it & write it back again
    sequence_file = File.new(filename, 'r+')
    begin
      sequence = sequence_file.read.to_i
      Mist.logger.debug "sequence=#{sequence}"
    rescue
      sequence = 1
    end
    name = "buildhost-#{sequence}"

    sequence += 1
    sequence_file.rewind
    sequence_file.write(sequence)
    sequence_file.close

    return name
  end
end

class MistServer
  def initialize
    @server = MessagePack::RPC::Server.new
    @server.listen('0.0.0.0', 18800, MistHandler.new)
  end

  def run
    @server.run
  end
end

# XXX Make this a command line option
daemonize = false
if daemonize
  # Provide our own file logger
  Mist.logger = Logger.new(File.join(%w(/ var log mist.log)))

  # Become a daemon & start processing requests
  Process.daemon(false, false)
else
  # Log to stderr
  Mist.logger = Logger.new(STDERR)
end

begin
  Mist.logger.info "Mist server starting with PID #{Process.pid}"

  server = MistServer.new
  server.run
rescue StandardError => ex
  Mist.logger.error "failed to start Mist server: #{ex}"
  abort
end

Mist.logger.info 'Mist server exiting'
exit 0
